<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Tesserae API Docs</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Tesserae</span> </span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="tesserae.core.html"><div class="inner"><span>tesserae.core</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="tesserae.core.html#var-await"><div class="inner"><span>await</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-chain"><div class="inner"><span>chain</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-delay"><div class="inner"><span>delay</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-delay-call"><div class="inner"><span>delay-call</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-fulfil"><div class="inner"><span>fulfil</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-fulfilled.3F"><div class="inner"><span>fulfilled?</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-fumble"><div class="inner"><span>fumble</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-fumbled.3F"><div class="inner"><span>fumbled?</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-future"><div class="inner"><span>future</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-future-call"><div class="inner"><span>future-call</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-get-error"><div class="inner"><span>get-error</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-now"><div class="inner"><span>now</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-now-call"><div class="inner"><span>now-call</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-pipeline"><div class="inner"><span>pipeline</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-promise"><div class="inner"><span>promise</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-redeem"><div class="inner"><span>redeem</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-revoke"><div class="inner"><span>revoke</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-revoke-chain"><div class="inner"><span>revoke-chain</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-revoked.3F"><div class="inner"><span>revoked?</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-tessera.3F"><div class="inner"><span>tessera?</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-unwatch"><div class="inner"><span>unwatch</span></div></a></li><li class="depth-1"><a href="tesserae.core.html#var-watch"><div class="inner"><span>watch</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">tesserae.core</h1><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-await"><h3>await</h3><div class="usage"><code>(await tessera)</code><code>(await tessera timeout-ms timeout-val)</code></div><div class="doc"><pre class="plaintext">Blocks until the tessera is no longer pending, but makes no
attempt to redeem. If the tessera's execution model would have the
redeeming thread perform the execution, then this does not
block. Returns the tessera, or timeout-val if timeout is met.</pre></div></div><div class="public anchor" id="var-chain"><h3>chain</h3><div class="usage"><code>(chain execution-model tessera f)</code></div><div class="doc"><pre class="plaintext">Returns a new tessera, chained off of this one. The supplied
function should take a single argument, the eventual value of this
tessera. When execution occurs is determined by the passed
execution-model. Tesserae that are chained enable
backward-propagation of cancellations via `revoke-chain`.

execution-model must be one of:
   - :future (clojure.core's future pool performs the work)
   - :delay (the thread that consumes the tessera performs the work)
   - :now (the current thread will perform the work, blocking if necessary)
   - :annex-future (see tesserae.execution.models/annexing-model)
   - :annex-delay (ibid.)
   - :annex-now (ibid.)
   - an ExecutorService (behaves like :future)
   - any other implementation of tesserae.protocols/ExecutionModel.</pre></div></div><div class="public anchor" id="var-delay"><h3>delay</h3><h4 class="type">macro</h4><div class="usage"><code>(delay &amp; body)</code></div><div class="doc"><pre class="plaintext">Corresponds to `clojure.core/delay`, returning instead a tessera
whose behavior is identical.</pre></div></div><div class="public anchor" id="var-delay-call"><h3>delay-call</h3><div class="usage"><code>(delay-call f)</code></div><div class="doc"><pre class="plaintext">As `future-call` is to `future`, so `delay-call` is to `delay`. Takes
a function of no arguments and returns a tessera whose value will be
computed by the first thread that redeems it (via `redeem` or
`clojure.core/deref`).</pre></div></div><div class="public anchor" id="var-fulfil"><h3>fulfil</h3><div class="usage"><code>(fulfil tessera v)</code></div><div class="doc"><pre class="plaintext">Attempts to fulfil the tessera by setting its value to v. Always
returns the tessera itself. If the tessera is no longer pending,
this does nothing. If the value is successfully set to v, then
this also executes all registered watch-functions and triggers
execution of any tesserae pipelined or chained off this one.</pre></div></div><div class="public anchor" id="var-fulfilled.3F"><h3>fulfilled?</h3><div class="usage"><code>(fulfilled? tessera)</code></div><div class="doc"><pre class="plaintext">A tessera is either pending, fulfilled successfully, revoked, or
fumbled. Returns true if this tessera has been fulfilled
successfully.</pre></div></div><div class="public anchor" id="var-fumble"><h3>fumble</h3><div class="usage"><code>(fumble tessera t)</code></div><div class="doc"><pre class="plaintext">Attempts to mark the tessera as fumbled, setting its value to the
Throwable t. After being fumbled, any attempt to redeem the tessera
will result in t being rethrown. The error may be fetched without
rethrowing via `get-error`.</pre></div></div><div class="public anchor" id="var-fumbled.3F"><h3>fumbled?</h3><div class="usage"><code>(fumbled? tessera)</code></div><div class="doc"><pre class="plaintext">A tessera is either pending, fulfilled successfully, revoked, or
fumbled. Returns true if this tessera is in an error state.</pre></div></div><div class="public anchor" id="var-future"><h3>future</h3><h4 class="type">macro</h4><div class="usage"><code>(future &amp; body)</code></div><div class="doc"><pre class="plaintext">Corresponds to `clojure.core/future`, returning instead a tessera
whose behavior is identical.</pre></div></div><div class="public anchor" id="var-future-call"><h3>future-call</h3><div class="usage"><code>(future-call f)</code></div><div class="doc"><pre class="plaintext">Corresponds to `clojure.core/future-call`, returning instead a
tessera whose behavior is identical.</pre></div></div><div class="public anchor" id="var-get-error"><h3>get-error</h3><div class="usage"><code>(get-error tessera)</code></div><div class="doc"><pre class="plaintext">Fetches the error from a fumbled or revoked tessera, without
rethrowing. Returns nil if the tessera is not fumbled.</pre></div></div><div class="public anchor" id="var-now"><h3>now</h3><h4 class="type">macro</h4><div class="usage"><code>(now &amp; body)</code></div><div class="doc"><pre class="plaintext">As with `future`, this takes a body of expressions and returns a
tessera representing the result of executing the expressions. Unlike
a `future`, the current thread performs the execution
immediately. If an error is encountered, the tessera is placed into
a fumbled state, but `now` itself will not throw.</pre></div></div><div class="public anchor" id="var-now-call"><h3>now-call</h3><div class="usage"><code>(now-call f)</code></div><div class="doc"><pre class="plaintext">As with `future-call`, accepts a function of no arguments, and
returns a tessera representing the result of invoking that function.
Unlike `future-call`, the current thread performs the execution
immediately. If an error is encountered, the tessera is placed into
a fumbled state, but `now-call` will not throw.</pre></div></div><div class="public anchor" id="var-pipeline"><h3>pipeline</h3><div class="usage"><code>(pipeline execution-model tessera f)</code></div><div class="doc"><pre class="plaintext">Returns a new tessera, pipelined off of this one. The supplied
function should take a single argument, the eventual value of this
tessera. When execution occurs is determined by the passed
execution-model. Tesserae that are pipelined do NOT allow
backward-propagation of revocations.

execution-model must be one of:
   - :future (clojure.core's future pool performs the work)
   - :delay (the thread that consumes the tessera performs the work)
   - :now (the current thread will perform the work, blocking if necessary)
   - :annex-future (see tesserae.execution.models/annexing-model)
   - :annex-delay (ibid.)
   - :annex-now (ibid.)
   - an ExecutorService (behaves like :future)
   - any other implementation of tesserae.protocols/ExecutionModel.</pre></div></div><div class="public anchor" id="var-promise"><h3>promise</h3><div class="usage"><code>(promise)</code></div><div class="doc"><pre class="plaintext">Returns a tessera corresponding to a regular promise in Clojure: its
value can be set by any thread, once only, with `fulfil` or
`clojure.core/deliver`. Its value can subsequently be read with
`redeem` or `clojure.core/deref`.</pre></div></div><div class="public anchor" id="var-redeem"><h3>redeem</h3><div class="usage"><code>(redeem tessera)</code><code>(redeem tessera timeout-ms timeout-val)</code></div><div class="doc"><pre class="plaintext">Retrieves the value represented by this tessera. Throws if the
tessera has been fumbled or revoked.</pre></div></div><div class="public anchor" id="var-revoke"><h3>revoke</h3><div class="usage"><code>(revoke tessera)</code><code>(revoke tessera may-interrupt?)</code><code>(revoke tessera may-interrupt? data)</code></div><div class="doc"><pre class="plaintext">Revokes the tessera, possibly interrupting any thread currently
working on fulfilling it. By default, this does not interrupt
threads. This revocation propagates to any dependent tesserae.

Revoked tesserae throw tesserae.CancellationExceptionInfo. If a
data map is provided, this is attached as ex-data.</pre></div></div><div class="public anchor" id="var-revoke-chain"><h3>revoke-chain</h3><div class="usage"><code>(revoke-chain tessera)</code><code>(revoke-chain tessera may-interrupt?)</code><code>(revoke-chain tessera may-interrupt? data)</code></div><div class="doc"><pre class="plaintext">Revokes the tessera, possibly interrupting any thread currently
working on fulfilling it. By default, this does not interrupt
threads. This revocation propagates down to any dependent
tesserae, as well as transitively back up to any tesserae this may
have been chained off of (but not pipelined).

Revoked tesserae throw tesserae.CancellationExceptionInfo. If a
data map is provided, this is attached as ex-data.</pre></div></div><div class="public anchor" id="var-revoked.3F"><h3>revoked?</h3><div class="usage"><code>(revoked? tessera)</code></div><div class="doc"><pre class="plaintext">A tessera is either pending, fulfilled successfully, revoked, or
fumbled. Returns true if this tessera has been revoked.</pre></div></div><div class="public anchor" id="var-tessera.3F"><h3>tessera?</h3><div class="usage"><code>(tessera? x)</code></div><div class="doc"><pre class="plaintext">Returns true if x is a tessera.
</pre></div></div><div class="public anchor" id="var-unwatch"><h3>unwatch</h3><div class="usage"><code>(unwatch tessera token)</code></div><div class="doc"><pre class="plaintext">Unregisters a watch function previously registered with `watch`.
Returns true on a success, false if the token matched no
function.</pre></div></div><div class="public anchor" id="var-watch"><h3>watch</h3><div class="usage"><code>(watch tessera f)</code><code>(watch tessera f executor)</code></div><div class="doc"><pre class="plaintext">Registers a callback function that is executed once this tessera
is no longer pending. The watch function should take one argument,
the tessera itself. On a success, this returns a unique token that
can be used to unregister the watch fn. Fails, returning false, if
the tessera is no longer pending.

By default, the watch function is executed by whatever thread
fulfils the tessera. If this is undesirable, an optional
ExecutorService may be provided.</pre></div></div></div></body></html>